# Summary
使用深度优先遍历计算每个城市被占领后强连通分量个数，需要修补的桥数为强连通分量数-1  

一开始不知道为什么会超时，想来想去找不到原因，好在这道题的代码量不是很大，逐一排查，最后发现是输入输出流的锅，恶补了一波cout和cin的知识，才知道cout和cin的性能差这么多。cout和cin的设计，可能比我们想象的复杂的多，从实际测试的结果，速度比printf和scanf慢一个数量级以上。影响cout和cin的性能的有两个方面：同步性和缓冲区，同步性可以通过ios_base::sync_with_stdio(false)禁用；操作系统会对缓冲区进行管理和优化，但十分有限，使用了endl之后，会对缓冲区执行清空操作，这个过程会先执行’\n’，再执行flush操作，非常漫长，所以尽量使用‘\n’而不是endl执行换行。然后，还有一个cout和cin的绑定效果，两者同时使用的话，cin与cout交替操作，会有一个flush过程，所以还是会很漫长，可以通过cin.tie(0)禁用绑定。但是需要注意的是，禁用同步之后，printf和scanf就不能用了，所以绕了一圈，还是用cin和cout吧……

PS 刚开始耍了点小聪明，在只有一个检查点超时过不去时删代码一直提交测试发现在接收道路数量时太大了导致超时，但如果限制一个上界他就通过了。。。于是我把接收边的循环中边界条件`i<m`改了`i<(m<33000?m:33000)`居然真的过了。。。  

PPS 之前为了防止重复输入道路，使用了set记录连接的城市。但内存又超了。。原来set比vector内存要求大